
## 트랜잭션 
### 📌 트랜잭션(Transaction)이 무엇인가? 
---
- 데이터베이스의 삽입(Insert), 갱신(UPDATE), 삭제(DELETE)와 같은 **DML 실행과 동시성 제어를 위한 하나의 논리적 작업 단위를 구성하는 연산들의 집합**이다.
- 보통은 **DML 실행부터 실행에 대한 COMMIT/ROLLBACK까지의 단계**를 트랜잭션이라고 부른다.
- 주로 여러 개의 수행이 들어왔을 경우 하나라도 실패하면 모든 수행을 실패하게 해야 하는 경우 사용한다.

<br>

>  - 대표적인 예로는 계좌 이체를 들 수 있다. 만약 A 계좌가 B 계좌로 송금을 했다면, 결과적으로 총 두 개의 수행이 일어나야 한다.
>  1) A 계좌에서의 인출
>  2) B 계좌에서의 입금
>- 이 수행들이 모두 합쳐져 **하나의 작업 단위**가 된다.
>- 이때 만약 인출은 됐는데 입금은 되지 않았다거나 인출이 되지 않았는데 입금이 됐다면 오류가 발생한 것이다. 모두 수행되거나 하나라도 되지 않았다면 모두 되지 않아야 한다.

<br>

### 📌 트랜잭션(Transaction)의 상태에는 어떤 것이 있는가?
---
![image](https://github.com/amazinguss/cs_study/assets/39427152/251e7fd6-d7e2-48ac-9878-0eb64cb35a88)
- 실행(active)이 발생하고 실행과 동시에 실패(failed)할 수도 있고, 부분 완료(Partially Committed)가 일어날 수도 있다.
- 이때 실패(failed)한다면 다음과 같이 철회되어 트랜잭션 수행 이전의 단계로 복원된다. -> `롤백(ROLLBACK)`
- 만약 부분 완료(Partially Committed) 후에도 실패(failed)한다면 모든 단계가 트랜잭션 수행 이전의 단계로 복원된다. -> `롤백(ROLLBACK)`
- 모든 과정이 완료(Committed)되었다면 트랜잭션의 수행을 저장해 주어야 한다. -> `커밋(COMMIT)`

|상태|설명|
|:---:|:---:|
|활동 (active)|트랜잭션이 실행 중에 있는 상태 (연산들이 정상적으로 실행 중인 상태)|
|부분 완료 (patially committed)|DML 등 트랜잭션의 모든 연산이 제대로 실행된 commit 연산 수행 이전의 상태|
|실패 (failed)|트랜잭션 실행의 오류가 발생한 상태|
|완료 (committed)|트랜잭션이 성공적으로 완료해 commit 연산이 수행된 상태|
|철회(aborted)|트랜잭션이 비정상적으로 종료돼 rollback 연산이 수행된 상태|


<br>

### 📌 트랜잭션(Transaction)의 연산에는 어떤 연산이 있는가? 
---
#### 1) COMMIT
- 트랜잭션에 대한 작업이 성공적으로 끝났을 때 **트랜잭션이 수행한 갱신 연산이 완료된 것을 트랜잭션 관리자에게 알려 주는 연산.**
- 즉, **트랜잭션의 작업 내용을 반영**하는 것이다.

#### 2) ROLLBACK
- 트랜잭션 내의 **하나의 수행이라도 실패했을 경우 비정상적으로 종료되어 트랜잭션이 수행한 모든 연산을 취소하는 연산.**
- 데이터베이스의 일관성을 깨트리지 않기 위한 단계로 ROLLBACK 시에는 트랜잭션을 재시작하거나 폐기한다.
- 즉, **트랜잭션의 작업 내용을 반영하지 않는 것**이다.

<br>

### 📌 트랜잭션(Transaction)의 성질은? 
---
 **기억해 두자 ACID**
- **원자성 (Atomicity)**
  - 트랜잭션의 모든 연산이 **정상적으로 수행 완료**되거나 **모두 수행되지 않는 것**을 보장해야 한다.
 
- **일관성 (Consistency)**
  - 트랜잭션이 성공적으로 완료되어도 **데이터베이스의 데이터가 일관되게 유지**되어야 한다.

- **독립성 (Isolation)**
  - 하나의 트랜잭션이 실행하는 도중에 변경한 데이터는 이 수행이 완료될 때까지 다른 트랜잭션이 참조하지 못한다.
  - 즉, **둘 이상의 트랜잭션이 동시 병행될 때 서로 독립적으로 실행**되어야 하고, 트랜잭션이 작업한 데이터를 수정할 수 없다.

- **지속성 (Durability)**
- **성공한 트랜잭션의 데이터는 저장되어 영구 보존**되어야 한다.

<br>

### 📌 트랜잭션(Transaction)의 고립 수준(Isolation Level)은 무엇이고, 종류에는 어떤 것이 있는가?
---
`격리 수준(Isolation Level)`이란 **트랜잭션에서 일관성이 없는 데이터를 허용하는 기준**이다.

<br>

**1. Read Uncommitted (Level 0)**
  - 수행 중인 트랜잭션 중 commit이 되지 않은 데이터를 다른 트랜잭션이 읽을 수 있다.
  - SELECT 수행 중 해당 데이터에 `공유 락(Shared Lock)`이 걸리지 않는 상태.
  - `Dirty Read`의 원인이 된다.
  - 데이터베이스의 일관성을 유지할 수 없다.

**2. Read Committed (Level 1)**
  - 먼저 수행되는 트랜잭션이 commit 하지 않는다면 다른 트랜잭션이 읽을 수 없다. 
  - 대부분의 SQL 서버의 `기본 값(default)`이다.
  - SELECT 수행 중 해당 데이터에  `공유 락(Shared Lock)`이 걸린 상태.
  - commit이 이루어진 트랜잭션만 조회할 수 있고, 트랜잭션이 수행되는 동안 그 데이터에 접근해야 하는 다른 트랜잭션은 대기하게 된다.

**3. Repeatable Read (Level 2)**
  - 트랜잭션이 완료될 때까지 SELECT 쿼리문이 사용하는 모든 데이터에 `공유 락(Shared Lock)`이 걸리는 상태.
  - 트랜잭션의 범위 내에 조회한 데이터의 내용이 항상 동일함이 보장된다.
  - 다른 사용자들은 그 영역에 해당하는 데이터에 대한 수정이 불가능하다. (읽기는 허용)
  - MySQL에서는 이 Level이 `기본 값(default)`이다.

**4. Serializable (Level 3)**
  - 트랜잭션이 완료될 때까지 SELECT 쿼리문이 사용하는 모든 데이터에 `공유 락(Shared Lock)`이 걸리는 상태.
  - Level 2와 달리 다른 사용자들이 그 영역에 해당하는 데이터를 수정이 불가능할 뿐만 아니라 삽입 역시 불가능하다.
  - 완벽한 읽기 일관성 모드를 제공한다.
  
<br>

### 📌 트랜잭션(Transaction)의 고립 수준(Isolation Level)을 선택할 때 고려해야 하는 부분이 무엇인가?
---
만약 `격리 수준(Isolation Level)`이 올라간다면 데이터의 무결성, 일관성은 향상되지만 더 넓은 범위의 Lock을 오래 유지해야 하므로 동시성은 떨어진다.
반대로 `격리 수준(Isolation Level)`이 내려간다면 동시성은 증가하고, 데이터의 무결성은 감소한다.
또한 `격리 수준(Isolation Level)`이 올라가면 비용 역시 증가함으로 이 부분도 고려해 보아야 한다.

<br>

### 📌 트랜잭션(Transaction)의 고립 수준(Isolation Level)이 낮을 시 발생할 수 있는 현상은 무엇인가?
---
![image](https://github.com/amazinguss/cs_study/assets/39427152/3b5348cd-649b-4a1d-9e9f-f9a7b0eb435b)
- Dirty Read
  - commit 되지 않은 수정 중인 데이터를 다른 트랜잭션에서 읽기를 허용할 경우 발생하는 현상.
  - 어떤 트랜잭션에서 아직 실행이 끝나지 않은 다른 트랜잭션에 의해 변경된 데이터를 보게 되는 경우를 말함.
  - 아직 commit 되지 않은 값을 읽었는데 이 값이 rollback이 되었다면? -> 잘못된 트랜잭션 수행 발생
 
- Non-Repeatable Read (Fuzzy Read)
  - 하나의 트랜잭션에서 같은 쿼리를 두 번 수행할 때 그 사이에 다른 트랜잭션이 값을 수정이나 삭제해서 두 쿼리의 결과에 일관성이 사라지는 현상.
  - 만약에 사용자 1이 SELECT를 통해 8이라는 값을 가지고 옴. 그런데 사용자 2가 값을 6로 수정하고 commit. 이후 사용자 1은 다시 조회할 때 8이 아닌 6이라는 결과를 받게 됨.
  
- Phantom Read
  - 한 트랜잭션 안에서 일정 범위의 레코드를 두 번 읽을 때 첫 번째 쿼리에서 없었던 레코드가 두 번째 쿼리에서 나타나는 현상.
  - 트랜잭션 도중 새로운 레코드 삽입을 허용하기 때문에 발생.
 

### 📌 트랜잭션(Transaction)의 독립성을 실현할 수 있는 방법은 무엇인가?
---
위와 같은 현상이 일어날 수 있음을 고려해 `고립 수준(Isolation Level)`을 정하고, 트랜잭션이 실행되는 동안 해당 필드에 `Lock`을 건다. 
하지만 무조건적인 `Lock`은 동시에 수행되는 많은 트랜잭션을 순서대로 처리하는 방식이 되므로 데이터베이스 성능이 떨어질 수 있다.
이를 고려해 효율적인 `Lock` 방법을 찾아야 한다.

