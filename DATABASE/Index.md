## 인덱스란?
데이터베이스 테이블의 검색 속도를 향상시키기 위한 자료구조
특정 칼럼에 인덱스를 생성하면, 해당 컬럼에 데이터를 정렬하여 별도의 메모리 공간에 데이터의 물리적 주소와 함께 저장된다.
인덱스 생성 컬럼을 where 조건으로 걸면 옵티마이저에서 판단하여 생성된 인덱스를 탈 수 있다.
![](https://velog.velcdn.com/images/soyeong125/post/cfaf4a9d-3291-4a44-ae87-a14a4448663a/image.png)
<img width="389" alt="image" src="https://github.com/amazinguss/cs_study/assets/57309311/48391e22-33a6-4649-ac2b-b62da7c3ffad">
위의 그림처럼 (age 칼럼을 정렬해서 새롭게 저장한 값)


### 인덱스의 특징
인덱스를 활용하면 select, update, delete의 성능이 함께 향상된다. 하지만 인덱스가 적용된 칼럼에 select, update, delete가 수행되면 index도 함께 select, update, delete에 대한 연산이 적용되기 때문에 오버헤드가 발생한다.
1. insert : 새로운 데이터에 대한 인덱스 추가
2. delete : 삭제할 데이터에 대해 사용하지 않음 작업 진행
3. update : 기존의 인덱스를 사용하지 않음 처리하고, 갱신된 데이터에 대한 인덱스 추가

### 인덱스의 장점
- 테이블 조회 속도와 성능 향상
- 전반적인 시스템 부하 감소

### 인덱스의 단점
- 인덱스를 관리하기 위한 DB의 약 10%에 해당하는 저장 공간 필요
- **인덱스의 특징** 에서 언급한 인덱스를 관리하기 위한 추가 작업 필요
- 인덱스를 잘못 사용할 경우 오히려 성능 저하되는 역효과 발생
- select, update, delete이 자주 발생하는 칼럼에 인덱스를 걸면 인덱스 데이터가 너무 많아져서 성능이 저하됨(delete, update시 사용안함 처리되는 데이터 때문에 사용하지 않는 인덱스를 바로바로 제거해줘야함)

### 인덱스를 사용해야 하는 경우
- 데이터가 많은 테이블인 경우 (1개의 데이터가 있는 테이블은 굳이 인덱스를 하지 않는 편이 좋다)
- select, update, delete가 자주 발생하지 않는 컬럼
- join이나 where 또는 order by 에 자주 사용되는 칼럼 (index를 통해 이미 sort되어 있기 때문에)
- 데이터 중복도가 낮은 칼럼(분포도가 최대한인 칼럼, PK를 인덱스로 하는 것이 가장 최선)
- 항상 = 으로 비교되는 컬럼

## 인덱스의 자료구조
인덱스를 구현하는 대표적인 자료구조는 **해시테이블**과 **B+Tree**이다.하지만 B+Tree테이블이 일반적으로 사용된다.

### 해시 테이블
해시 테이블은 (Key,Value)로 데이터를 저장하는 자료구조 중 하나로 빠른 데이터 검색이 필요할 때 유용하다.해시 테이블은 Key값을 이용해 고유한 index를 생성하여 index에 저장된 값을 꺼내오는 구조이다.
![](https://velog.velcdn.com/images/soyeong125/post/43db1fe6-62ba-4b07-9d7d-c418779b67e0/image.png)

해시 테이블 기반의 인덱스는 데이터(Value)를 (컬럼의 값, 위치)로 사용하여 컬럼의 값으로 생성된 해시를 통해 인덱스(Key)를 구현한다. 해시 테이블의 시간 복잡도는 O(1)이며 매우 빠른 검색을 지원한다. 하지만 인덱스에서 **해시 테이블이 사용되는 경우는 매우 제한적**이다. 그 이유는 **해시가 = 연산에 특화**되었기 때문에 **부등호 연산이 자주 사용되는 데이터베이스 검색에는 해시 테이블이 적합하지 않다.**

## B Tree
B+Tree는 B Tree를 개선시킨 구조이다. B Tree의 구조를 먼저 살펴보자.
<img width="696" alt="image" src="https://github.com/amazinguss/cs_study/assets/57309311/d767c050-6150-44b7-bdde-522d05bf59ab">

### B Tree 특징
- 자식 노드의 개수가 2개 이상인 트리이다.
- 노드 내의 데이터가 1개 이상일 수 있다.
- 노드의 데이터 수가 n개라면 자식 노드의 개수는 n+1개 이다 (초기 root 경우나 leaf 노드 제외)
- Balance가 맞춰져 있는 이진 탐색 트리(이진탐색 + 연결리스트)이다.
- 왼쪽부터 작은 값, 오른쪽엔 큰 값으로 이루어져 있다.
- root노드 부터 시작해서 하향식으로 찾고자 하는 값을 탐색한다.
- 최악의 경우 O(logn)의 시간 복잡도를 가진다 (leaf node 까지 가는 경우)

### B+Tree
인덱스를 위해 자식 노드가 2개 이상인 B-Tree를 개선시킨 자료구조이다. MySQL의 DB engine인 InnoDB는 B+Tree로 이루어져있다.

#### B+Tree 특징 
<img width="689" alt="image" src="https://github.com/amazinguss/cs_study/assets/57309311/1657c626-1d2a-4405-ae63-9482f30d02ce">

- leaf node에만 인덱스(key)와 함께 데이터(value)를 가지고 있고, 나머지 노드들은 데이터를 위한 인덱스(Key)를 가지고 있다.
- lead node들은 LinkedList로 연결되어 있고 오름차순 정렬되어 있다.
- 데이터 노드 크기는 인덱스 노드의 크기와 같지 않아도 된다.
- BTree는 리프노드 까지 가지 않아도 데이터를 탐색할 수 있었지만 B+Tree는 무조건 leaf node까지 가야한다.
- B+Tree는 O(logn)의 시간복잡도를 갖는다.
- 범위 검색, 부등호 검색에 유용하다.

#### B+Tree 장점
- leaf node를 제외하고 데이터를 담아두지 않기 때문에 메로리를 더 확보함으로써 더 많은 key를 수용할 수 있다. 하나의 노드에 더 많은 key를 담을 수 있기 때문에 트리 높이가 낮아져 **cache hit**를 높일 수 있다.
- Full Scan시 B+Tree는 리프 노드에 데이터가 있기 때문에 한번의 선형 탐색만 하면 되기 때문에 B-Tree에 비해 탐색 시간이 빠르다


옵티마이저: 가장 효율적으로 SQL을 수행할 최적의 경로를 생성해주는 DBMS의 핵심 엔진으로 컴퓨터에서 CPU같은 존재이다.

>참고
>https://youtu.be/iNvYsGKelYs
