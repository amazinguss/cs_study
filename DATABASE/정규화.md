# 정규화 (Normalization)
데이터베이스 설계에서 중복을 제거하고 데이터를 구조화하는 과정이다.
이를 통해 데이터의 일관성, 효율성, 유지보수성을 향상시킬 수 있다. 
정규화는 관계형 데이터베이스에서 흔히 사용되며, 여러 개의 정규형으로 나누어진 단계적인 접근 방법을 따른다.

## 목표
정규화의 목표는 데이터의 이상(anomaly)을 제거하는 것이다. 
이상은 데이터의 중복, 종속성, 비일관성 등과 관련되어 있어 이상이 발생하면 데이터의 무결성과 일관성이 저하될 수 있으며, 데이터의 수정, 삽입, 삭제 작업에도 문제가 발생할 수 있다.

## 단계
정규화는 일반적으로 1차 정규형부터 5차 정규형까지의 단계로 구분되고 각 단계마다 해결할 수 있는 데이터의 이상현상이 있다.


### 1차 정규형(1NF)
![image](https://github.com/amazinguss/cs_study/assets/103317018/33a068e2-168d-4ac9-a34b-38eebce7d043)

각 테이블의 모든 속성이 원자 값(Atomic Value)으로 이루어져야 한다. 속성의 중복을 제거하고, 각 행은 유일한 식별자를 가져야 한다. 이를 통해 2가지 이상현상을 해결한다.
#### 삽입 이상 (Insertion Anomaly)
데이터의 삽입 시 중복된 데이터가 발생하는 것을 방지한다.
* 예) 한 학생의 정보를 저장하는 테이블에서 학생의 주소 정보를 추가하려고 할 때, 주소 정보가 모든 학생의 행에 중복해서 삽입되는 문제를 해결
#### 삭제 이상 (Deletion Anomaly)
데이터의 삭제 시 관련된 다른 정보도 함께 삭제되는 것을 방지한다. 
* 예) 한 학생의 정보를 저장하는 테이블에서 학생의 과목 성적 정보를 삭제하면 해당 학생의 기본 정보까지 함께 삭제되는 문제를 해결

### 2차 정규형(2NF)
1차 정규형을 만족하면서 부분 함수적 종속성을 제거한다. 즉, 기본 키를 제외한 모든 속성이 **기본 키(Primay key)에 대해 완전 함수적 종속성**을 가져야 한다.
> #### 함수적 종속성 (Functional Dependency) 이란?
> 함수적 종속성은 데이터베이스에서 속성 간의 관계를 나타내는 개념으로, 한 속성의 값을 다른 속성의 값에 의존하는 관계를 말한다.
> * 함수적 종속성은 다음과 같이 표현된다 : A → B
> * 여기서 A는 결정자(Determinant), B는 종속자(Dependent)라고 한다. 즉, A의 값이 주어지면 B의 값을 알 수 있고, A의 값이 변경되면 B의 값도 변경될 수 있다.
> * 예) 주문 테이블에서 "주문번호 → 주문일자"라는 함수적 종속성이 있다고 가정할 때, 여기서 주문번호는 결정자이며, 주문번호를 알면 해당 주문의 주문일자를 알 수 있다. 

아래와 같은 테이블(학생의 수강 강의와 강의료 정보)이 있다. 
* COURSE_NO -> COURSE_FEE, 즉 COURSE_FEE는 COURSE_NO에 종속되며 이는 후보 키의 적절한 하위 집합이다. 
* COURSE_FEE는 부분 종속성인 후보 키의 적절한 하위 집합에 종속되므로 2NF가 아니다. 

| STUD_NO | COURSE_NO | COURSE_FEE |
|---------|-----------|------------|
| 1       | C1        | 1000       |
| 2       | C2        | 1500       |
| 1       | C4        | 2000       |
| 4       | C3        | 1000       |
| 4       | C1        | 1000       |
| 2       | C5        | 2000       |

* 2NF로 변환하려면 테이블을 다음과 같은 두 개의 테이블로 분할해야 한다. 

테이블 1: STUD_NO, COURSE_NO   
| STUD_NO | COURSE_NO |
|---------|-----------|
| 1       | C1        |
| 2       | C2        |
| 1       | C4        |
| 4       | C3        |
| 4       | C1        |
| 2       | C5        |

테이블 2: COURSE_NO, COURSE_FEE   
| COURSE_NO | COURSE_FEE |
|-----------|------------|
| C1        | 1000       |
| C2        | 1500       |
| C3        | 1000       |
| C4        | 2000       |
| C5        | 2000       |

이를 통해 기본 키의 일부 속성이 다른 비기본 키 속성에 종속되는 **부분종속성(Partial Dependency)을 해결**한다.

### 3차 정규형(3NF)
2차 정규형을 만족하면서 이행 종속성(Transitive Dependency)을 제거한다. 즉, 비기본 속성이 기본 키가 아닌 다른 비기본 속성에 종속되어서는 안된다.
> #### 이행종속성(Transitive Dependency)이란?
> 함수적 종속성의 일종으로, A가 B에 종속하고 B가 C에 종속할 때, A가 C에 종속하는 관계이다.
> * 예) 예를 들어, 학생 테이블에서 (학번, 이름, 학과, 학과장)의 속성이 있을 때, 학과장은 학과에 종속되며 학과는 학번에 종속된다. 
> 이 경우, 학번(A)을 통해 학과(B)를 알 수 있고, 학과(B)를 통해 학과장(C)을 알 수 있으므로 학번(A)에 종속된 학과장(C)의 속성이 생기게 된다.

![image](https://github.com/amazinguss/cs_study/assets/103317018/08013ce8-8ffb-4d89-afab-ea0708c577e4)
위 예시 테이블을 볼 때, 종속 관계는 이렇다.
* STUD_NO -> STUD_NAME
* **STUD_NO -> STUD_STATE**
* STUD_NO -> STUD_AGE
* **STUD_STATE -> STUD_COUNTRY**

`STUD_NO -> STUD_STATE -> STUD_COUNTRY` 이므로 `STUD_NO -> STUD_COUNTRY` 의 이행종속성이 존재하기 때문에 3차 정규형을 만족하지 못한다.
이를 제3정규형으로 변환하기 위해서는 다음과 같이 테이블을 분해해야 한다.

* STUDENT (STUD_NO, STUD_NAME, STUD_PHONE, STUD_STATE, STUD_AGE) 
* STATE_COUNTRY (STATE, COUNTRY)
 

### 보이스-코드 정규형(BCNF)
3차 정규형을 만족하면서 결정자에 대한 이행 종속성을 제거합니다. 즉, 모든 결정자가 후보 키여야 하고, 결정자가 아닌 모든 속성이 결정자에 완전 함수적으로 종속되어야 한다.
예) A -> B 일 때, A가 후보키여야 함

| 학번 | 학과 | 성적 |
|------|------|------|
|  1   |  IT  |  90  |
|  2   |  CS  |  85  |
|  3   |  IT  |  75  |

위의 예시에서 학생(Student) 테이블의 학번은 결정자이며, 학과와 성적은 학번에 대해 완전 함수적으로 종속되어 있다. 
그러나 학과는 성적에 대해 부분 함수적 종속 관계를 가지고 있다. 즉, 학과가 주어지면 성적을 유일하게 결정할 수 없어 보이스-코드 정규형을 만족하지 않는다.

이를 해결하기 위해서는 아래와 같이 두개의 테이블로 나눈다.

학생(Student) 테이블:
| 학번 | 학과 |
|------|------|
|  1   |  IT  |
|  2   |  CS  |
|  3   |  IT  |

성적(Score) 테이블:
| 학번 | 성적 |
|------|------|
|  1   |  90  |
|  2   |  85  |
|  3   |  75  |

이렇게 되면 학생 테이블에서는 결정자가 아닌 속성인 학과 속성이 학번에 종속되고, 성적 테이블에서는 결정자가 아닌 성적 속성이 학번에 종속되어 BCNF를 만족한다.
